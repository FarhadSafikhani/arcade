{"version":3,"file":"snake-FedGEJd8.js","sources":["../../src/games/snake/snake.ts","../../src/games/snake/food.ts","../../src/games/snake/game.ts"],"sourcesContent":["import { Container, Graphics } from 'pixi.js';\r\n\r\ntype Direction = 'up' | 'down' | 'left' | 'right';\r\n\r\ninterface Position {\r\n    x: number;\r\n    y: number;\r\n}\r\n\r\nexport class Snake {\r\n    public container: Container;\r\n    private segments: Position[] = [];\r\n    private direction: Direction = 'right';\r\n    private nextDirection: Direction = 'right';\r\n    private gridSize: number;\r\n    private gridWidth: number;\r\n    private gridHeight: number;\r\n    private graphics: Graphics;\r\n\r\n    constructor(gridSize: number, gridWidth: number, gridHeight: number) {\r\n        this.gridSize = gridSize;\r\n        this.gridWidth = gridWidth;\r\n        this.gridHeight = gridHeight;\r\n        \r\n        this.container = new Container();\r\n        this.graphics = new Graphics();\r\n        this.container.addChild(this.graphics);\r\n        \r\n        this.reset();\r\n    }\r\n\r\n    reset(): void {\r\n        // Initialize snake at center of grid\r\n        const startX = Math.floor(this.gridWidth / 2);\r\n        const startY = Math.floor(this.gridHeight / 2);\r\n        \r\n        this.segments = [\r\n            { x: startX, y: startY },\r\n            { x: startX - 1, y: startY },\r\n            { x: startX - 2, y: startY }\r\n        ];\r\n        \r\n        this.direction = 'right';\r\n        this.nextDirection = 'right';\r\n        this.draw();\r\n    }\r\n\r\n    setDirection(newDirection: Direction): void {\r\n        // Prevent 180-degree turns\r\n        if (\r\n            (this.direction === 'up' && newDirection === 'down') ||\r\n            (this.direction === 'down' && newDirection === 'up') ||\r\n            (this.direction === 'left' && newDirection === 'right') ||\r\n            (this.direction === 'right' && newDirection === 'left')\r\n        ) {\r\n            return;\r\n        }\r\n        \r\n        this.nextDirection = newDirection;\r\n    }\r\n\r\n    move(): Position {\r\n        // Update direction\r\n        this.direction = this.nextDirection;\r\n        \r\n        // Get current head position\r\n        const head = this.segments[0];\r\n        const newHead: Position = { x: head.x, y: head.y };\r\n        \r\n        // Calculate new head position based on direction\r\n        switch (this.direction) {\r\n            case 'up':\r\n                newHead.y -= 1;\r\n                break;\r\n            case 'down':\r\n                newHead.y += 1;\r\n                break;\r\n            case 'left':\r\n                newHead.x -= 1;\r\n                break;\r\n            case 'right':\r\n                newHead.x += 1;\r\n                break;\r\n        }\r\n        \r\n        // Add new head\r\n        this.segments.unshift(newHead);\r\n        \r\n        // Remove tail (unless growing)\r\n        this.segments.pop();\r\n        \r\n        this.draw();\r\n        return newHead;\r\n    }\r\n\r\n    grow(): void {\r\n        // Add a new segment at the tail position\r\n        const tail = this.segments[this.segments.length - 1];\r\n        this.segments.push({ x: tail.x, y: tail.y });\r\n    }\r\n\r\n    checkCollision(x: number, y: number): boolean {\r\n        // Check if position collides with any snake segment\r\n        return this.segments.some(segment => segment.x === x && segment.y === y);\r\n    }\r\n\r\n    checkCollisionWithBody(x: number, y: number): boolean {\r\n        // Check if position collides with any snake segment except the head\r\n        return this.segments.slice(1).some(segment => segment.x === x && segment.y === y);\r\n    }\r\n\r\n    private draw(): void {\r\n        this.graphics.clear();\r\n        \r\n        // Draw each segment\r\n        this.segments.forEach((segment, index) => {\r\n            const x = segment.x * this.gridSize;\r\n            const y = segment.y * this.gridSize;\r\n            \r\n            // Head is a different color\r\n            if (index === 0) {\r\n                this.graphics.beginFill(0x2ecc71);\r\n            } else {\r\n                this.graphics.beginFill(0x27ae60);\r\n            }\r\n            \r\n            // Draw rounded rectangle for each segment\r\n            this.graphics.drawRoundedRect(x + 1, y + 1, this.gridSize - 2, this.gridSize - 2, 3);\r\n            this.graphics.endFill();\r\n            \r\n            // Add border\r\n            this.graphics.lineStyle(2, 0x229954, 0.8);\r\n            this.graphics.drawRoundedRect(x + 1, y + 1, this.gridSize - 2, this.gridSize - 2, 3);\r\n            \r\n            // Add eyes to head\r\n            if (index === 0) {\r\n                this.drawEyes(x, y);\r\n            }\r\n        });\r\n    }\r\n\r\n    private drawEyes(x: number, y: number): void {\r\n        const eyeSize = 3;\r\n        const eyeOffset = 5;\r\n        \r\n        // Eye positions based on direction\r\n        let leftEyeX: number, leftEyeY: number, rightEyeX: number, rightEyeY: number;\r\n        \r\n        switch (this.direction) {\r\n            case 'up':\r\n                leftEyeX = x + eyeOffset;\r\n                leftEyeY = y + eyeOffset;\r\n                rightEyeX = x + this.gridSize - eyeOffset - eyeSize;\r\n                rightEyeY = y + eyeOffset;\r\n                break;\r\n            case 'down':\r\n                leftEyeX = x + eyeOffset;\r\n                leftEyeY = y + this.gridSize - eyeOffset - eyeSize;\r\n                rightEyeX = x + this.gridSize - eyeOffset - eyeSize;\r\n                rightEyeY = y + this.gridSize - eyeOffset - eyeSize;\r\n                break;\r\n            case 'left':\r\n                leftEyeX = x + eyeOffset;\r\n                leftEyeY = y + eyeOffset;\r\n                rightEyeX = x + eyeOffset;\r\n                rightEyeY = y + this.gridSize - eyeOffset - eyeSize;\r\n                break;\r\n            case 'right':\r\n                leftEyeX = x + this.gridSize - eyeOffset - eyeSize;\r\n                leftEyeY = y + eyeOffset;\r\n                rightEyeX = x + this.gridSize - eyeOffset - eyeSize;\r\n                rightEyeY = y + this.gridSize - eyeOffset - eyeSize;\r\n                break;\r\n        }\r\n        \r\n        // Draw eyes\r\n        this.graphics.beginFill(0x000000);\r\n        this.graphics.drawCircle(leftEyeX, leftEyeY, eyeSize);\r\n        this.graphics.drawCircle(rightEyeX, rightEyeY, eyeSize);\r\n        this.graphics.endFill();\r\n    }\r\n\r\n    getHead(): Position {\r\n        return this.segments[0];\r\n    }\r\n\r\n    getLength(): number {\r\n        return this.segments.length;\r\n    }\r\n} ","import { Container, Graphics } from 'pixi.js';\r\n\r\nexport class Food {\r\n    public container: Container;\r\n    public x: number = 0;\r\n    public y: number = 0;\r\n    private graphics: Graphics;\r\n    private gridSize: number;\r\n    private animationTime: number = 0;\r\n\r\n    constructor(gridSize: number) {\r\n        this.gridSize = gridSize;\r\n        this.container = new Container();\r\n        this.graphics = new Graphics();\r\n        this.container.addChild(this.graphics);\r\n    }\r\n\r\n    setPosition(x: number, y: number): void {\r\n        this.x = x;\r\n        this.y = y;\r\n        this.draw();\r\n    }\r\n\r\n    private draw(): void {\r\n        this.graphics.clear();\r\n        \r\n        const centerX = this.x * this.gridSize + this.gridSize / 2;\r\n        const centerY = this.y * this.gridSize + this.gridSize / 2;\r\n        const radius = this.gridSize / 2 - 2;\r\n        \r\n        // Draw main food circle\r\n        this.graphics.beginFill(0xe74c3c);\r\n        this.graphics.drawCircle(centerX, centerY, radius);\r\n        this.graphics.endFill();\r\n        \r\n        // Add border\r\n        this.graphics.lineStyle(2, 0xc0392b, 0.8);\r\n        this.graphics.drawCircle(centerX, centerY, radius);\r\n        \r\n        // Add shine effect\r\n        this.graphics.beginFill(0xffffff);\r\n        this.graphics.drawCircle(centerX - radius / 3, centerY - radius / 3, radius / 4);\r\n        this.graphics.endFill();\r\n        \r\n        // Add bite marks (make it look like an apple)\r\n        this.graphics.beginFill(0x2c3e50);\r\n        this.graphics.drawEllipse(centerX + radius / 2, centerY - radius / 2, radius / 6, radius / 3);\r\n        this.graphics.endFill();\r\n    }\r\n\r\n    update(delta: number): void {\r\n        // Add subtle animation\r\n        this.animationTime += delta;\r\n        const scale = 1 + Math.sin(this.animationTime * 0.1) * 0.05;\r\n        this.container.scale.set(scale);\r\n    }\r\n} ","import { Application, Container, Graphics, Text, TextStyle } from 'pixi.js';\r\nimport { Snake } from './snake';\r\nimport { Food } from './food';\r\n\r\n// Responsive game constants\r\nconst getGameDimensions = () => {\r\n    // 1. Get window dimensions and calculate max workable space\r\n    const windowWidth = window.innerWidth;\r\n    const windowHeight = window.innerHeight;\r\n    const maxWorkableWidth = windowWidth - 40; // 20px padding on each side\r\n    const maxWorkableHeight = windowHeight - 250; // More conservative - leave more space for UI\r\n    \r\n    // 2. Determine grid count based on screen size\r\n    const isMobile = windowWidth < 768;\r\n    const gridColumns = isMobile ? 10 : 15;\r\n    let gridRows = isMobile ? 15 : 20;\r\n    \r\n    // 3. Calculate grid size to fit within available space\r\n    const maxGridSizeFromWidth = maxWorkableWidth / gridColumns;\r\n    const maxGridSizeFromHeight = maxWorkableHeight / gridRows;\r\n    let gridSize = Math.floor(Math.min(maxGridSizeFromWidth, maxGridSizeFromHeight));\r\n    \r\n    // 4. Recalculate if the game would overflow and adjust row count\r\n    const gameWidth = gridColumns * gridSize;\r\n    const gameHeight = gridRows * gridSize;\r\n    \r\n    // If game height would overflow, reduce row count\r\n    if (gameHeight > maxWorkableHeight) {\r\n        gridRows = Math.floor(maxWorkableHeight / gridSize);\r\n        // Recalculate grid size with new row count\r\n        const newMaxGridSizeFromHeight = maxWorkableHeight / gridRows;\r\n        gridSize = Math.floor(Math.min(maxGridSizeFromWidth, newMaxGridSizeFromHeight));\r\n    }\r\n    \r\n    // 5. Calculate final game dimensions\r\n    const finalGameWidth = gridColumns * gridSize;\r\n    const finalGameHeight = gridRows * gridSize;\r\n    \r\n    return {\r\n        gridSize,\r\n        gridWidth: gridColumns,\r\n        gridHeight: gridRows,\r\n        gameWidth: finalGameWidth,\r\n        gameHeight: finalGameHeight\r\n    };\r\n};\r\n\r\nexport class SnakeGame {\r\n    private app: Application;\r\n    private gameContainer: Container;\r\n    private snake!: Snake;\r\n    private food!: Food;\r\n    private score: number = 0;\r\n    private highScore: number = 0;\r\n    private gameSpeed: number = 150; // milliseconds between moves\r\n    private lastMoveTime: number = 0;\r\n    private isGameOver: boolean = false;\r\n    private isPaused: boolean = false;\r\n    private isWaitingToStart: boolean = true;\r\n    private removeInputHandler?: () => void;\r\n    private removeTouchHandler?: () => void;\r\n\r\n    // Game constants - will be set dynamically\r\n    private GRID_SIZE: number;\r\n    private GRID_WIDTH: number;\r\n    private GRID_HEIGHT: number;\r\n    private GAME_WIDTH: number;\r\n    private GAME_HEIGHT: number;\r\n\r\n    constructor(app: Application) {\r\n        this.app = app;\r\n        this.gameContainer = new Container();\r\n        this.app.stage.addChild(this.gameContainer);\r\n        \r\n        // Set dimensions based on screen size\r\n        const dimensions = getGameDimensions();\r\n        this.GRID_SIZE = dimensions.gridSize;\r\n        this.GRID_WIDTH = dimensions.gridWidth;\r\n        this.GRID_HEIGHT = dimensions.gridHeight;\r\n        this.GAME_WIDTH = dimensions.gameWidth;\r\n        this.GAME_HEIGHT = dimensions.gameHeight;\r\n        \r\n        // Load high score from localStorage\r\n        this.highScore = parseInt(localStorage.getItem('snakeHighScore') || '0');\r\n    }\r\n\r\n    async init(): Promise<void> { \r\n        // Create game background\r\n        this.createBackground();\r\n        \r\n        // Initialize snake\r\n        this.snake = new Snake(this.GRID_SIZE, this.GRID_WIDTH, this.GRID_HEIGHT);\r\n        this.gameContainer.addChild(this.snake.container);\r\n        \r\n        // Initialize food\r\n        this.food = new Food(this.GRID_SIZE);\r\n        this.gameContainer.addChild(this.food.container);\r\n        \r\n        // Position food\r\n        this.spawnFood();\r\n        \r\n        // Set up input handling\r\n        this.setupInput();\r\n        this.setupTouchControls();\r\n        this.setupStartScreen();\r\n        \r\n        // Initialize UI\r\n        this.updateUI();\r\n    }\r\n\r\n    private createBackground(): void {\r\n        const background = new Graphics();\r\n        background.beginFill(0x34495e);\r\n        background.drawRect(0, 0, this.GAME_WIDTH, this.GAME_HEIGHT);\r\n        background.endFill();\r\n        \r\n        // Draw grid lines\r\n        background.lineStyle(1, 0x2c3e50, 1);\r\n        for (let x = 0; x <= this.GRID_WIDTH; x++) {\r\n            background.moveTo(x * this.GRID_SIZE, 0);\r\n            background.lineTo(x * this.GRID_SIZE, this.GAME_HEIGHT);\r\n        }\r\n        for (let y = 0; y <= this.GRID_HEIGHT; y++) {\r\n            background.moveTo(0, y * this.GRID_SIZE);\r\n            background.lineTo(this.GAME_WIDTH, y * this.GRID_SIZE);\r\n        }\r\n        \r\n        this.gameContainer.addChild(background);\r\n    }\r\n\r\n    private setupInput(): void {\r\n        const handleKeydown = (event: KeyboardEvent) => {\r\n            if (this.isGameOver) return;\r\n            \r\n            switch (event.key) {\r\n                case 'ArrowUp':\r\n                case 'w':\r\n                case 'W':\r\n                    event.preventDefault();\r\n                    this.snake.setDirection('up');\r\n                    break;\r\n                case 'ArrowDown':\r\n                case 's':\r\n                case 'S':\r\n                    event.preventDefault();\r\n                    this.snake.setDirection('down');\r\n                    break;\r\n                case 'ArrowLeft':\r\n                case 'a':\r\n                case 'A':\r\n                    event.preventDefault();\r\n                    this.snake.setDirection('left');\r\n                    break;\r\n                case 'ArrowRight':\r\n                case 'd':\r\n                case 'D':\r\n                    event.preventDefault();\r\n                    this.snake.setDirection('right');\r\n                    break;\r\n                case ' ':\r\n                case 'Escape':\r\n                    event.preventDefault();\r\n                    this.togglePause();\r\n                    break;\r\n            }\r\n        };\r\n\r\n        document.addEventListener('keydown', handleKeydown);\r\n        \r\n        // Store the handler so we can remove it later\r\n        this.removeInputHandler = () => {\r\n            document.removeEventListener('keydown', handleKeydown);\r\n        };\r\n    }\r\n\r\n    private setupTouchControls(): void {\r\n        let startX = 0;\r\n        let startY = 0;\r\n        let isSwiping = false;\r\n        const minSwipeDistance = 30;\r\n\r\n        const handleTouchStart = (event: TouchEvent) => {\r\n            if (this.isGameOver) return;\r\n            \r\n            const touch = event.touches[0];\r\n            startX = touch.clientX;\r\n            startY = touch.clientY;\r\n            isSwiping = true;\r\n        };\r\n\r\n        const handleTouchMove = (event: TouchEvent) => {\r\n            if (!isSwiping) return;\r\n            event.preventDefault();\r\n        };\r\n\r\n        const handleTouchEnd = (event: TouchEvent) => {\r\n            if (!isSwiping) return;\r\n            \r\n            const touch = event.changedTouches[0];\r\n            const deltaX = touch.clientX - startX;\r\n            const deltaY = touch.clientY - startY;\r\n            \r\n            if (Math.abs(deltaX) > minSwipeDistance || Math.abs(deltaY) > minSwipeDistance) {\r\n                if (Math.abs(deltaX) > Math.abs(deltaY)) {\r\n                    // Horizontal swipe\r\n                    if (deltaX > 0) {\r\n                        this.snake.setDirection('right');\r\n                    } else {\r\n                        this.snake.setDirection('left');\r\n                    }\r\n                } else {\r\n                    // Vertical swipe\r\n                    if (deltaY > 0) {\r\n                        this.snake.setDirection('down');\r\n                    } else {\r\n                        this.snake.setDirection('up');\r\n                    }\r\n                }\r\n            }\r\n            \r\n            isSwiping = false;\r\n        };\r\n\r\n        const canvas = this.app.view as HTMLCanvasElement;\r\n        canvas.addEventListener('touchstart', handleTouchStart, { passive: false });\r\n        canvas.addEventListener('touchmove', handleTouchMove, { passive: false });\r\n        canvas.addEventListener('touchend', handleTouchEnd, { passive: false });\r\n        \r\n        this.removeTouchHandler = () => {\r\n            canvas.removeEventListener('touchstart', handleTouchStart);\r\n            canvas.removeEventListener('touchmove', handleTouchMove);\r\n            canvas.removeEventListener('touchend', handleTouchEnd);\r\n        };\r\n    }\r\n\r\n    private setupStartScreen(): void {\r\n        // Create start screen overlay\r\n        const startScreen = document.createElement('div');\r\n        startScreen.id = 'startScreen';\r\n        startScreen.style.cssText = `\r\n            position: absolute;\r\n            top: 0;\r\n            left: 0;\r\n            right: 0;\r\n            bottom: 0;\r\n            background: rgba(0, 0, 0, 0.8);\r\n            display: flex;\r\n            flex-direction: column;\r\n            justify-content: center;\r\n            align-items: center;\r\n            color: white;\r\n            text-align: center;\r\n            z-index: 30;\r\n            cursor: pointer;\r\n        `;\r\n        \r\n        startScreen.innerHTML = `\r\n            <h2 style=\"margin: 0 0 20px 0; font-size: 24px;\">🐍 Snake</h2>\r\n            <p style=\"margin: 0 0 30px 0; font-size: 16px; opacity: 0.8;\">\r\n                Click or tap to start<br>\r\n                Use arrow keys or swipe to control\r\n            </p>\r\n            <div style=\"font-size: 14px; opacity: 0.6;\">\r\n                Desktop: Arrow keys or WASD<br>\r\n                Mobile: Swipe to control\r\n            </div>\r\n        `;\r\n        \r\n        const gameContainer = document.getElementById('gameContainer');\r\n        if (gameContainer) {\r\n            gameContainer.appendChild(startScreen);\r\n        }\r\n        \r\n        // Add click/tap handler to start game\r\n        const startGame = () => {\r\n            this.isWaitingToStart = false;\r\n            this.lastMoveTime = Date.now();\r\n            startScreen.style.display = 'none';\r\n        };\r\n        \r\n        startScreen.addEventListener('click', startGame);\r\n        startScreen.addEventListener('touchstart', startGame, { passive: true });\r\n    }\r\n\r\n    update(delta: number): void {\r\n        if (this.isGameOver || this.isPaused || this.isWaitingToStart) return;\r\n\r\n        const currentTime = Date.now();\r\n        if (currentTime - this.lastMoveTime > this.gameSpeed) {\r\n            this.moveSnake();\r\n            this.lastMoveTime = currentTime;\r\n        }\r\n    }\r\n\r\n    private moveSnake(): void {\r\n        const head = this.snake.move();\r\n        \r\n        // Check for wall collision\r\n        if (head.x < 0 || head.x >= this.GRID_WIDTH || \r\n            head.y < 0 || head.y >= this.GRID_HEIGHT) {\r\n            this.gameOver();\r\n            return;\r\n        }\r\n        \r\n        // Check for self collision (excluding the head itself)\r\n        if (this.snake.checkCollisionWithBody(head.x, head.y)) {\r\n            this.gameOver();\r\n            return;\r\n        }\r\n        \r\n        // Check for food collision\r\n        if (head.x === this.food.x && head.y === this.food.y) {\r\n            this.snake.grow();\r\n            this.spawnFood();\r\n            this.score += 1;\r\n            this.updateUI();\r\n            \r\n            // Increase speed every 50 points\r\n            if (this.score % 50 === 0 && this.gameSpeed > 50) {\r\n                this.gameSpeed -= 10;\r\n            }\r\n        }\r\n    }\r\n\r\n    private spawnFood(): void {\r\n        let x: number, y: number;\r\n        do {\r\n            x = Math.floor(Math.random() * this.GRID_WIDTH);\r\n            y = Math.floor(Math.random() * this.GRID_HEIGHT);\r\n        } while (this.snake.checkCollision(x, y));\r\n        \r\n        this.food.setPosition(x, y);\r\n    }\r\n\r\n    private gameOver(): void {\r\n        this.isGameOver = true;\r\n        \r\n        // Update high score\r\n        if (this.score > this.highScore) {\r\n            this.highScore = this.score;\r\n            localStorage.setItem('snakeHighScore', this.highScore.toString());\r\n            this.updateUI();\r\n        }\r\n        \r\n        // Show game over screen\r\n        this.showGameOver();\r\n    }\r\n\r\n    private showGameOver(): void {\r\n        const gameOverElement = document.getElementById('gameOver');\r\n        const finalScoreElement = document.getElementById('finalScore');\r\n        \r\n        if (gameOverElement && finalScoreElement) {\r\n            finalScoreElement.textContent = this.score.toString();\r\n            gameOverElement.style.display = 'block';\r\n        }\r\n    }\r\n\r\n    togglePause(): void {\r\n        this.isPaused = !this.isPaused;\r\n        \r\n        if (this.isPaused) {\r\n            this.showPauseMenu();\r\n        } else {\r\n            this.hidePauseMenu();\r\n        }\r\n    }\r\n\r\n    private showPauseMenu(): void {\r\n        const pauseMenuElement = document.getElementById('pauseMenu');\r\n        if (pauseMenuElement) {\r\n            pauseMenuElement.style.display = 'block';\r\n        }\r\n    }\r\n\r\n    private hidePauseMenu(): void {\r\n        const pauseMenuElement = document.getElementById('pauseMenu');\r\n        if (pauseMenuElement) {\r\n            pauseMenuElement.style.display = 'none';\r\n        }\r\n    }\r\n\r\n    private updateUI(): void {\r\n        const scoreElement = document.getElementById('score');\r\n        const highScoreElement = document.getElementById('highScore');\r\n        \r\n        if (scoreElement) scoreElement.textContent = this.score.toString();\r\n        if (highScoreElement) highScoreElement.textContent = this.highScore.toString();\r\n    }\r\n\r\n    restart(): void { \r\n        this.score = 0;\r\n        this.gameSpeed = 150;\r\n        this.isGameOver = false;\r\n        this.isPaused = false;\r\n        this.isWaitingToStart = true;\r\n        this.lastMoveTime = 0;\r\n        \r\n        this.snake.reset();\r\n        this.spawnFood();\r\n        this.updateUI();\r\n        \r\n        // Hide game over modal\r\n        const gameOverElement = document.getElementById('gameOver');\r\n        if (gameOverElement) {\r\n            gameOverElement.style.display = 'none';\r\n        }\r\n        \r\n        // Hide pause menu\r\n        this.hidePauseMenu();\r\n        \r\n        // Show start screen\r\n        const startScreen = document.getElementById('startScreen');\r\n        if (startScreen) {\r\n            startScreen.style.display = 'flex';\r\n        }\r\n    }\r\n\r\n    resume(): void {\r\n        this.isPaused = false;\r\n        this.hidePauseMenu();\r\n    }\r\n\r\n    destroy(): void {\r\n        if (this.removeInputHandler) {\r\n            this.removeInputHandler();\r\n        }\r\n        if (this.removeTouchHandler) {\r\n            this.removeTouchHandler();\r\n        }\r\n        if (this.gameContainer && this.gameContainer.parent) {\r\n            this.gameContainer.parent.removeChild(this.gameContainer);\r\n        }\r\n    }\r\n}\r\n\r\n// Global game instance\r\nlet game: SnakeGame | null = null;\r\nlet app: Application | null = null;\r\n\r\n// Initialize the game when the page loads\r\nasync function initGame() {\r\n    // Get dynamic dimensions\r\n    const dimensions = getGameDimensions();\r\n    \r\n    // Create PIXI application\r\n    app = new Application({\r\n        width: dimensions.gameWidth,\r\n        height: dimensions.gameHeight,\r\n        backgroundColor: 0x2c3e50,\r\n        antialias: true,\r\n        resolution: window.devicePixelRatio || 1,\r\n    });\r\n\r\n    // Add canvas to game container\r\n    const gameContainer = document.getElementById('gameContainer');\r\n    if (gameContainer) {\r\n        const canvas = app.view as HTMLCanvasElement;\r\n        // Set CSS dimensions to match the app dimensions (not the canvas buffer size)\r\n        canvas.style.width = `${dimensions.gameWidth}px`;\r\n        canvas.style.height = `${dimensions.gameHeight}px`;\r\n        canvas.style.maxWidth = '100%';\r\n        canvas.style.maxHeight = '100%';\r\n        gameContainer.appendChild(canvas);\r\n    }\r\n\r\n    // Create and initialize game\r\n    game = new SnakeGame(app);\r\n    await game.init();\r\n\r\n    // Set up game loop\r\n    app.ticker.add(gameLoop);\r\n}\r\n\r\nfunction gameLoop(delta: number) {\r\n    if (game) {\r\n        game.update(delta);\r\n    }\r\n}\r\n\r\n// Global functions for game control\r\ndeclare global {\r\n    interface Window {\r\n        restartGame: () => void;\r\n        returnToMainMenu: () => void;\r\n        resumeGame: () => void;\r\n        togglePause: () => void;\r\n    }\r\n}\r\n\r\nwindow.restartGame = () => {\r\n    if (game) {\r\n        game.restart();\r\n    }\r\n};\r\n\r\nwindow.returnToMainMenu = () => {\r\n    window.location.href = '/arcade/';\r\n};\r\n\r\nwindow.resumeGame = () => {\r\n    if (game) {\r\n        game.resume();\r\n    }\r\n};\r\n\r\nwindow.togglePause = () => {\r\n    if (game) {\r\n        game.togglePause();\r\n    }\r\n};\r\n\r\n// Initialize when page loads\r\nwindow.addEventListener('load', initGame); "],"names":["Snake","gridSize","gridWidth","gridHeight","__publicField","Container","Graphics","startX","startY","newDirection","head","newHead","tail","x","y","segment","index","leftEyeX","leftEyeY","rightEyeX","rightEyeY","Food","centerX","centerY","radius","delta","scale","getGameDimensions","windowWidth","windowHeight","maxWorkableWidth","maxWorkableHeight","isMobile","gridColumns","gridRows","maxGridSizeFromWidth","maxGridSizeFromHeight","newMaxGridSizeFromHeight","finalGameWidth","finalGameHeight","SnakeGame","app","dimensions","background","handleKeydown","event","isSwiping","minSwipeDistance","handleTouchStart","touch","handleTouchMove","handleTouchEnd","deltaX","deltaY","canvas","startScreen","gameContainer","startGame","currentTime","gameOverElement","finalScoreElement","pauseMenuElement","scoreElement","highScoreElement","game","initGame","Application","gameLoop"],"mappings":"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"}