{"version":3,"file":"snake-CtXS91I5.js","sources":["../../src/games/snake/snake.ts","../../src/games/snake/food.ts","../../src/games/snake/game.ts"],"sourcesContent":["import { Container, Graphics } from 'pixi.js';\r\n\r\ntype Direction = 'up' | 'down' | 'left' | 'right';\r\n\r\ninterface Position {\r\n    x: number;\r\n    y: number;\r\n}\r\n\r\nexport class Snake {\r\n    public container: Container;\r\n    private segments: Position[] = [];\r\n    private direction: Direction = 'right';\r\n    private nextDirection: Direction = 'right';\r\n    private gridSize: number;\r\n    private gridWidth: number;\r\n    private gridHeight: number;\r\n    private graphics: Graphics;\r\n\r\n    constructor(gridSize: number, gridWidth: number, gridHeight: number) {\r\n        this.gridSize = gridSize;\r\n        this.gridWidth = gridWidth;\r\n        this.gridHeight = gridHeight;\r\n        \r\n        this.container = new Container();\r\n        this.graphics = new Graphics();\r\n        this.container.addChild(this.graphics);\r\n        \r\n        this.reset();\r\n    }\r\n\r\n    reset(): void {\r\n        // Initialize snake at center of grid\r\n        const startX = Math.floor(this.gridWidth / 2);\r\n        const startY = Math.floor(this.gridHeight / 2);\r\n        \r\n        this.segments = [\r\n            { x: startX, y: startY },\r\n            { x: startX - 1, y: startY },\r\n            { x: startX - 2, y: startY }\r\n        ];\r\n        \r\n        this.direction = 'right';\r\n        this.nextDirection = 'right';\r\n        this.draw();\r\n    }\r\n\r\n    setDirection(newDirection: Direction): void {\r\n        // Prevent 180-degree turns\r\n        if (\r\n            (this.direction === 'up' && newDirection === 'down') ||\r\n            (this.direction === 'down' && newDirection === 'up') ||\r\n            (this.direction === 'left' && newDirection === 'right') ||\r\n            (this.direction === 'right' && newDirection === 'left')\r\n        ) {\r\n            return;\r\n        }\r\n        \r\n        this.nextDirection = newDirection;\r\n    }\r\n\r\n    move(): Position {\r\n        // Update direction\r\n        this.direction = this.nextDirection;\r\n        \r\n        // Get current head position\r\n        const head = this.segments[0];\r\n        const newHead: Position = { x: head.x, y: head.y };\r\n        \r\n        // Calculate new head position based on direction\r\n        switch (this.direction) {\r\n            case 'up':\r\n                newHead.y -= 1;\r\n                break;\r\n            case 'down':\r\n                newHead.y += 1;\r\n                break;\r\n            case 'left':\r\n                newHead.x -= 1;\r\n                break;\r\n            case 'right':\r\n                newHead.x += 1;\r\n                break;\r\n        }\r\n        \r\n        // Add new head\r\n        this.segments.unshift(newHead);\r\n        \r\n        // Remove tail (unless growing)\r\n        this.segments.pop();\r\n        \r\n        this.draw();\r\n        return newHead;\r\n    }\r\n\r\n    grow(): void {\r\n        // Add a new segment at the tail position\r\n        const tail = this.segments[this.segments.length - 1];\r\n        this.segments.push({ x: tail.x, y: tail.y });\r\n    }\r\n\r\n    checkCollision(x: number, y: number): boolean {\r\n        // Check if position collides with any snake segment\r\n        return this.segments.some(segment => segment.x === x && segment.y === y);\r\n    }\r\n\r\n    checkCollisionWithBody(x: number, y: number): boolean {\r\n        // Check if position collides with any snake segment except the head\r\n        return this.segments.slice(1).some(segment => segment.x === x && segment.y === y);\r\n    }\r\n\r\n    private draw(): void {\r\n        this.graphics.clear();\r\n        \r\n        // Draw each segment\r\n        this.segments.forEach((segment, index) => {\r\n            const x = segment.x * this.gridSize;\r\n            const y = segment.y * this.gridSize;\r\n            \r\n            // Head is a different color\r\n            if (index === 0) {\r\n                this.graphics.beginFill(0x2ecc71);\r\n            } else {\r\n                this.graphics.beginFill(0x27ae60);\r\n            }\r\n            \r\n            // Draw rounded rectangle for each segment\r\n            this.graphics.drawRoundedRect(x + 1, y + 1, this.gridSize - 2, this.gridSize - 2, 3);\r\n            this.graphics.endFill();\r\n            \r\n            // Add border\r\n            this.graphics.lineStyle(2, 0x229954, 0.8);\r\n            this.graphics.drawRoundedRect(x + 1, y + 1, this.gridSize - 2, this.gridSize - 2, 3);\r\n            \r\n            // Add eyes to head\r\n            if (index === 0) {\r\n                this.drawEyes(x, y);\r\n            }\r\n        });\r\n    }\r\n\r\n    private drawEyes(x: number, y: number): void {\r\n        const eyeSize = 3;\r\n        const eyeOffset = 5;\r\n        \r\n        // Eye positions based on direction\r\n        let leftEyeX: number, leftEyeY: number, rightEyeX: number, rightEyeY: number;\r\n        \r\n        switch (this.direction) {\r\n            case 'up':\r\n                leftEyeX = x + eyeOffset;\r\n                leftEyeY = y + eyeOffset;\r\n                rightEyeX = x + this.gridSize - eyeOffset - eyeSize;\r\n                rightEyeY = y + eyeOffset;\r\n                break;\r\n            case 'down':\r\n                leftEyeX = x + eyeOffset;\r\n                leftEyeY = y + this.gridSize - eyeOffset - eyeSize;\r\n                rightEyeX = x + this.gridSize - eyeOffset - eyeSize;\r\n                rightEyeY = y + this.gridSize - eyeOffset - eyeSize;\r\n                break;\r\n            case 'left':\r\n                leftEyeX = x + eyeOffset;\r\n                leftEyeY = y + eyeOffset;\r\n                rightEyeX = x + eyeOffset;\r\n                rightEyeY = y + this.gridSize - eyeOffset - eyeSize;\r\n                break;\r\n            case 'right':\r\n                leftEyeX = x + this.gridSize - eyeOffset - eyeSize;\r\n                leftEyeY = y + eyeOffset;\r\n                rightEyeX = x + this.gridSize - eyeOffset - eyeSize;\r\n                rightEyeY = y + this.gridSize - eyeOffset - eyeSize;\r\n                break;\r\n        }\r\n        \r\n        // Draw eyes\r\n        this.graphics.beginFill(0x000000);\r\n        this.graphics.drawCircle(leftEyeX, leftEyeY, eyeSize);\r\n        this.graphics.drawCircle(rightEyeX, rightEyeY, eyeSize);\r\n        this.graphics.endFill();\r\n    }\r\n\r\n    getHead(): Position {\r\n        return this.segments[0];\r\n    }\r\n\r\n    getLength(): number {\r\n        return this.segments.length;\r\n    }\r\n} ","import { Container, Graphics } from 'pixi.js';\r\n\r\nexport class Food {\r\n    public container: Container;\r\n    public x: number = 0;\r\n    public y: number = 0;\r\n    private graphics: Graphics;\r\n    private gridSize: number;\r\n    private animationTime: number = 0;\r\n\r\n    constructor(gridSize: number) {\r\n        this.gridSize = gridSize;\r\n        this.container = new Container();\r\n        this.graphics = new Graphics();\r\n        this.container.addChild(this.graphics);\r\n    }\r\n\r\n    setPosition(x: number, y: number): void {\r\n        this.x = x;\r\n        this.y = y;\r\n        this.draw();\r\n    }\r\n\r\n    private draw(): void {\r\n        this.graphics.clear();\r\n        \r\n        const centerX = this.x * this.gridSize + this.gridSize / 2;\r\n        const centerY = this.y * this.gridSize + this.gridSize / 2;\r\n        const radius = this.gridSize / 2 - 2;\r\n        \r\n        // Draw main food circle\r\n        this.graphics.beginFill(0xe74c3c);\r\n        this.graphics.drawCircle(centerX, centerY, radius);\r\n        this.graphics.endFill();\r\n        \r\n        // Add border\r\n        this.graphics.lineStyle(2, 0xc0392b, 0.8);\r\n        this.graphics.drawCircle(centerX, centerY, radius);\r\n        \r\n        // Add shine effect\r\n        this.graphics.beginFill(0xffffff);\r\n        this.graphics.drawCircle(centerX - radius / 3, centerY - radius / 3, radius / 4);\r\n        this.graphics.endFill();\r\n        \r\n        // Add bite marks (make it look like an apple)\r\n        this.graphics.beginFill(0x2c3e50);\r\n        this.graphics.drawEllipse(centerX + radius / 2, centerY - radius / 2, radius / 6, radius / 3);\r\n        this.graphics.endFill();\r\n    }\r\n\r\n    update(delta: number): void {\r\n        // Add subtle animation\r\n        this.animationTime += delta;\r\n        const scale = 1 + Math.sin(this.animationTime * 0.1) * 0.05;\r\n        this.container.scale.set(scale);\r\n    }\r\n} ","import { Application, Container, Graphics } from 'pixi.js';\r\nimport { Snake } from './snake';\r\nimport { Food } from './food';\r\n\r\n// Game constants - base dimensions that will be flipped based on screen orientation\r\nconst BASE_DIMENSIONS = {\r\n    landscape: { width: 600, height: 400 },\r\n    portrait: { width: 400, height: 600 }\r\n};\r\nconst GRID_SIZE = 40; // 40 on large screen space, 5\r\n\r\n// Function to determine game dimensions based on screen orientation\r\nconst getGameDimensions = () => {\r\n    const windowWidth = window.innerWidth;\r\n    const windowHeight = window.innerHeight - 120; // Account for top bar and margins\r\n    \r\n    // Determine if screen is landscape or portrait\r\n    const isLandscape = windowWidth > windowHeight;\r\n    const baseDimensions = isLandscape ? BASE_DIMENSIONS.landscape : BASE_DIMENSIONS.portrait;\r\n    \r\n    // Calculate grid dimensions based on orientation\r\n    const gridWidth = baseDimensions.width / GRID_SIZE;\r\n    const gridHeight = baseDimensions.height / GRID_SIZE;\r\n    \r\n    // Calculate scale to fit within available space while maintaining aspect ratio\r\n    const scaleX = windowWidth / baseDimensions.width;\r\n    const scaleY = windowHeight / baseDimensions.height;\r\n    const scale = Math.min(scaleX, scaleY);\r\n    \r\n    return {\r\n        gameWidth: baseDimensions.width,\r\n        gameHeight: baseDimensions.height,\r\n        gridWidth: Math.floor(gridWidth),\r\n        gridHeight: Math.floor(gridHeight),\r\n        scale,\r\n        isLandscape\r\n    };\r\n};\r\n\r\nexport class SnakeGame {\r\n    private app: Application;\r\n    private gameContainer: Container;\r\n    private snake!: Snake;\r\n    private food!: Food;\r\n    private score: number = 0;\r\n    private highScore: number = 0;\r\n    private gameSpeed: number = 150; // milliseconds between moves\r\n    private lastMoveTime: number = 0;\r\n    private isGameOver: boolean = false;\r\n    private isPaused: boolean = false;\r\n    private isWaitingToStart: boolean = true;\r\n    private removeInputHandler?: () => void;\r\n    private removeTouchHandler?: () => void;\r\n    private gameDimensions: ReturnType<typeof getGameDimensions>;\r\n\r\n    constructor(app: Application) {\r\n        this.app = app;\r\n        this.gameContainer = new Container();\r\n        this.app.stage.addChild(this.gameContainer);\r\n        \r\n        // Get initial dimensions\r\n        this.gameDimensions = getGameDimensions();\r\n        \r\n        // Load high score from localStorage\r\n        this.highScore = parseInt(localStorage.getItem('snakeHighScore') || '0');\r\n    }\r\n\r\n    // Public getter for game dimensions\r\n    getGameDimensions() {\r\n        return this.gameDimensions;\r\n    }\r\n\r\n    async init(): Promise<void> { \r\n        // Create game background\r\n        this.createBackground();\r\n        \r\n        // Initialize snake with current grid dimensions\r\n        this.snake = new Snake(GRID_SIZE, this.gameDimensions.gridWidth, this.gameDimensions.gridHeight);\r\n        this.gameContainer.addChild(this.snake.container);\r\n        \r\n        // Initialize food\r\n        this.food = new Food(GRID_SIZE);\r\n        this.gameContainer.addChild(this.food.container);\r\n        \r\n        // Position food\r\n        this.spawnFood();\r\n        \r\n        // Set up input handling\r\n        this.setupInput();\r\n        this.setupTouchControls();\r\n        this.setupStartScreen();\r\n        \r\n        // Initialize UI\r\n        this.updateUI();\r\n    }\r\n\r\n    private createBackground(): void {\r\n        const background = new Graphics();\r\n        background.beginFill(0x34495e);\r\n        background.drawRect(0, 0, this.gameDimensions.gameWidth, this.gameDimensions.gameHeight);\r\n        background.endFill();\r\n        \r\n        // Draw grid lines\r\n        background.lineStyle(1, 0x2c3e50, 1);\r\n        for (let x = 0; x <= this.gameDimensions.gridWidth; x++) {\r\n            background.moveTo(x * GRID_SIZE, 0);\r\n            background.lineTo(x * GRID_SIZE, this.gameDimensions.gameHeight);\r\n        }\r\n        for (let y = 0; y <= this.gameDimensions.gridHeight; y++) {\r\n            background.moveTo(0, y * GRID_SIZE);\r\n            background.lineTo(this.gameDimensions.gameWidth, y * GRID_SIZE);\r\n        }\r\n        \r\n        this.gameContainer.addChild(background);\r\n    }\r\n\r\n    private setupInput(): void {\r\n        const handleKeydown = (event: KeyboardEvent) => {\r\n            if (this.isGameOver) return;\r\n            \r\n            switch (event.key) {\r\n                case 'ArrowUp':\r\n                case 'w':\r\n                case 'W':\r\n                    event.preventDefault();\r\n                    this.snake.setDirection('up');\r\n                    break;\r\n                case 'ArrowDown':\r\n                case 's':\r\n                case 'S':\r\n                    event.preventDefault();\r\n                    this.snake.setDirection('down');\r\n                    break;\r\n                case 'ArrowLeft':\r\n                case 'a':\r\n                case 'A':\r\n                    event.preventDefault();\r\n                    this.snake.setDirection('left');\r\n                    break;\r\n                case 'ArrowRight':\r\n                case 'd':\r\n                case 'D':\r\n                    event.preventDefault();\r\n                    this.snake.setDirection('right');\r\n                    break;\r\n                case ' ':\r\n                case 'Escape':\r\n                    event.preventDefault();\r\n                    this.togglePause();\r\n                    break;\r\n            }\r\n        };\r\n\r\n        document.addEventListener('keydown', handleKeydown);\r\n        \r\n        // Store the handler so we can remove it later\r\n        this.removeInputHandler = () => {\r\n            document.removeEventListener('keydown', handleKeydown);\r\n        };\r\n    }\r\n\r\n    private setupTouchControls(): void {\r\n        let startX = 0;\r\n        let startY = 0;\r\n        let isSwiping = false;\r\n        const minSwipeDistance = 30;\r\n\r\n        const handleTouchStart = (event: TouchEvent) => {\r\n            if (this.isGameOver) return;\r\n            \r\n            const touch = event.touches[0];\r\n            startX = touch.clientX;\r\n            startY = touch.clientY;\r\n            isSwiping = true;\r\n        };\r\n\r\n        const handleTouchMove = (event: TouchEvent) => {\r\n            if (!isSwiping) return;\r\n            event.preventDefault();\r\n        };\r\n\r\n        const handleTouchEnd = (event: TouchEvent) => {\r\n            if (!isSwiping) return;\r\n            \r\n            const touch = event.changedTouches[0];\r\n            const deltaX = touch.clientX - startX;\r\n            const deltaY = touch.clientY - startY;\r\n            const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);\r\n            \r\n            if (distance >= minSwipeDistance) {\r\n                // Determine swipe direction\r\n                if (Math.abs(deltaX) > Math.abs(deltaY)) {\r\n                    // Horizontal swipe\r\n                    if (deltaX > 0) {\r\n                        this.snake.setDirection('right');\r\n                    } else {\r\n                        this.snake.setDirection('left');\r\n                    }\r\n                } else {\r\n                    // Vertical swipe\r\n                    if (deltaY > 0) {\r\n                        this.snake.setDirection('down');\r\n                    } else {\r\n                        this.snake.setDirection('up');\r\n                    }\r\n                }\r\n            }\r\n            \r\n            isSwiping = false;\r\n        };\r\n\r\n        // Add touch listeners to document for full screen control\r\n        document.addEventListener('touchstart', handleTouchStart, { passive: false });\r\n        document.addEventListener('touchmove', handleTouchMove, { passive: false });\r\n        document.addEventListener('touchend', handleTouchEnd, { passive: false });\r\n        \r\n        this.removeTouchHandler = () => {\r\n            document.removeEventListener('touchstart', handleTouchStart);\r\n            document.removeEventListener('touchmove', handleTouchMove);\r\n            document.removeEventListener('touchend', handleTouchEnd);\r\n        };\r\n    }\r\n\r\n    private setupStartScreen(): void {\r\n        // Create start screen overlay\r\n        const startScreen = document.createElement('div');\r\n        startScreen.id = 'startScreen';\r\n        startScreen.style.cssText = `\r\n            position: absolute;\r\n            top: 0;\r\n            left: 0;\r\n            right: 0;\r\n            bottom: 0;\r\n            background: rgba(0, 0, 0, 0.8);\r\n            display: flex;\r\n            flex-direction: column;\r\n            justify-content: center;\r\n            align-items: center;\r\n            color: white;\r\n            text-align: center;\r\n            z-index: 30;\r\n            cursor: pointer;\r\n        `;\r\n        \r\n        startScreen.innerHTML = `\r\n            <h2 style=\"margin: 0 0 20px 0; font-size: 24px;\">üêç Snake</h2>\r\n            <p style=\"margin: 0 0 30px 0; font-size: 16px; opacity: 0.8;\">\r\n                Click or tap to start<br>\r\n                Use arrow keys or swipe to control\r\n            </p>\r\n            <div style=\"font-size: 14px; opacity: 0.6;\">\r\n                Desktop: Arrow keys or WASD<br>\r\n                Mobile: Swipe to control\r\n            </div>\r\n        `;\r\n        \r\n        const gameContainer = document.getElementById('gameContainer');\r\n        if (gameContainer) {\r\n            gameContainer.appendChild(startScreen);\r\n        }\r\n        \r\n        // Add click/tap handler to start game\r\n        const startGame = () => {\r\n            this.isWaitingToStart = false;\r\n            this.lastMoveTime = Date.now();\r\n            startScreen.style.display = 'none';\r\n        };\r\n        \r\n        startScreen.addEventListener('click', startGame);\r\n        startScreen.addEventListener('touchstart', startGame, { passive: true });\r\n    }\r\n\r\n    update(delta: number): void {\r\n        if (this.isGameOver || this.isPaused || this.isWaitingToStart) return;\r\n\r\n        const currentTime = Date.now();\r\n        if (currentTime - this.lastMoveTime > this.gameSpeed) {\r\n            this.moveSnake();\r\n            this.lastMoveTime = currentTime;\r\n        }\r\n    }\r\n\r\n    private moveSnake(): void {\r\n        const head = this.snake.move();\r\n        \r\n        // Check for wall collision\r\n        if (head.x < 0 || head.x >= this.gameDimensions.gridWidth || \r\n            head.y < 0 || head.y >= this.gameDimensions.gridHeight) {\r\n            this.gameOver();\r\n            return;\r\n        }\r\n        \r\n        // Check for self collision (excluding the head itself)\r\n        if (this.snake.checkCollisionWithBody(head.x, head.y)) {\r\n            this.gameOver();\r\n            return;\r\n        }\r\n        \r\n        // Check for food collision\r\n        if (head.x === this.food.x && head.y === this.food.y) {\r\n            this.snake.grow();\r\n            this.spawnFood();\r\n            this.score += 1;\r\n            this.updateUI();\r\n            \r\n            // Increase speed every 50 points\r\n            if (this.score % 50 === 0 && this.gameSpeed > 50) {\r\n                this.gameSpeed -= 10;\r\n            }\r\n        }\r\n    }\r\n\r\n    private spawnFood(): void {\r\n        let x: number, y: number;\r\n        do {\r\n            x = Math.floor(Math.random() * this.gameDimensions.gridWidth);\r\n            y = Math.floor(Math.random() * this.gameDimensions.gridHeight);\r\n        } while (this.snake.checkCollision(x, y));\r\n        \r\n        this.food.setPosition(x, y);\r\n    }\r\n\r\n    private gameOver(): void {\r\n        this.isGameOver = true;\r\n        \r\n        // Update high score\r\n        if (this.score > this.highScore) {\r\n            this.highScore = this.score;\r\n            localStorage.setItem('snakeHighScore', this.highScore.toString());\r\n            this.updateUI();\r\n        }\r\n        \r\n        // Show game over screen\r\n        this.showGameOver();\r\n    }\r\n\r\n    private showGameOver(): void {\r\n        const gameOverElement = document.getElementById('gameOver');\r\n        const finalScoreElement = document.getElementById('finalScore');\r\n        \r\n        if (gameOverElement && finalScoreElement) {\r\n            finalScoreElement.textContent = this.score.toString();\r\n            gameOverElement.style.display = 'block';\r\n        }\r\n    }\r\n\r\n    togglePause(): void {\r\n        this.isPaused = !this.isPaused;\r\n        \r\n        if (this.isPaused) {\r\n            this.showPauseMenu();\r\n        } else {\r\n            this.hidePauseMenu();\r\n        }\r\n    }\r\n\r\n    private showPauseMenu(): void {\r\n        const pauseMenuElement = document.getElementById('pauseMenu');\r\n        if (pauseMenuElement) {\r\n            pauseMenuElement.style.display = 'block';\r\n        }\r\n    }\r\n\r\n    private hidePauseMenu(): void {\r\n        const pauseMenuElement = document.getElementById('pauseMenu');\r\n        if (pauseMenuElement) {\r\n            pauseMenuElement.style.display = 'none';\r\n        }\r\n    }\r\n\r\n    private updateUI(): void {\r\n        const scoreElement = document.getElementById('score');\r\n        const highScoreElement = document.getElementById('highScore');\r\n        \r\n        if (scoreElement) scoreElement.textContent = this.score.toString();\r\n        if (highScoreElement) highScoreElement.textContent = this.highScore.toString();\r\n    }\r\n\r\n    restart(): void { \r\n        this.score = 0;\r\n        this.gameSpeed = 150;\r\n        this.isGameOver = false;\r\n        this.isPaused = false;\r\n        this.isWaitingToStart = true;\r\n        this.lastMoveTime = 0;\r\n        \r\n        this.snake.reset();\r\n        this.spawnFood();\r\n        this.updateUI();\r\n        \r\n        // Hide game over modal\r\n        const gameOverElement = document.getElementById('gameOver');\r\n        if (gameOverElement) {\r\n            gameOverElement.style.display = 'none';\r\n        }\r\n        \r\n        // Hide pause menu\r\n        this.hidePauseMenu();\r\n        \r\n        // Show start screen\r\n        const startScreen = document.getElementById('startScreen');\r\n        if (startScreen) {\r\n            startScreen.style.display = 'flex';\r\n        }\r\n    }\r\n\r\n    resume(): void {\r\n        this.isPaused = false;\r\n        this.hidePauseMenu();\r\n    }\r\n\r\n    destroy(): void {\r\n        if (this.removeInputHandler) {\r\n            this.removeInputHandler();\r\n        }\r\n        if (this.removeTouchHandler) {\r\n            this.removeTouchHandler();\r\n        }\r\n        if (this.gameContainer && this.gameContainer.parent) {\r\n            this.gameContainer.parent.removeChild(this.gameContainer);\r\n        }\r\n    }\r\n}\r\n\r\n// Global game instance\r\nlet game: SnakeGame | null = null;\r\nlet app: Application | null = null;\r\n\r\n// Function to update canvas scaling on resize\r\nfunction updateCanvasScaling() {\r\n    if (!app) return;\r\n    \r\n    // Get current dimensions but use the existing orientation\r\n    const currentDimensions = game?.getGameDimensions();\r\n    if (!currentDimensions) return;\r\n    \r\n    const windowWidth = window.innerWidth;\r\n    const windowHeight = window.innerHeight - 120;\r\n    \r\n    // Use the existing game dimensions but recalculate scale\r\n    const scaleX = windowWidth / currentDimensions.gameWidth;\r\n    const scaleY = windowHeight / currentDimensions.gameHeight;\r\n    const scale = Math.min(scaleX, scaleY);\r\n    \r\n    const canvas = app.view as HTMLCanvasElement;\r\n    \r\n    // Update canvas CSS dimensions with new scale but same game dimensions\r\n    canvas.style.width = `${currentDimensions.gameWidth * scale}px`;\r\n    canvas.style.height = `${currentDimensions.gameHeight * scale}px`;\r\n    \r\n    // Check if orientation changed significantly (more than just a small resize)\r\n    const newDimensions = getGameDimensions();\r\n    const currentOrientation = currentDimensions.isLandscape;\r\n    const newOrientation = newDimensions.isLandscape;\r\n    \r\n    // If orientation changed, log it but don't change the game\r\n    if (currentOrientation !== newOrientation) {\r\n        console.log('Orientation changed but keeping current game orientation:', { \r\n            current: currentOrientation ? 'landscape' : 'portrait',\r\n            new: newOrientation ? 'landscape' : 'portrait',\r\n            note: 'Game will use new orientation on restart'\r\n        });\r\n    }\r\n}\r\n\r\n// Initialize the game when the page loads\r\nasync function initGame() {\r\n    // Get dimensions and scale\r\n    const dimensions = getGameDimensions();\r\n    \r\n    // Create PIXI application with base dimensions\r\n    app = new Application({\r\n        width: dimensions.gameWidth,\r\n        height: dimensions.gameHeight,\r\n        backgroundColor: 0x2c3e50,\r\n        antialias: true,\r\n        resolution: window.devicePixelRatio || 1,\r\n    });\r\n\r\n    // Add canvas to game container with proper scaling\r\n    const gameContainer = document.getElementById('gameContainer');\r\n    if (gameContainer) {\r\n        const canvas = app.view as HTMLCanvasElement;\r\n        \r\n        // Apply scaling through CSS transform\r\n        canvas.style.width = `${dimensions.gameWidth * dimensions.scale}px`;\r\n        canvas.style.height = `${dimensions.gameHeight * dimensions.scale}px`;\r\n        canvas.style.maxWidth = '100%';\r\n        canvas.style.maxHeight = '100%';\r\n        canvas.style.objectFit = 'contain';\r\n        \r\n        gameContainer.appendChild(canvas);\r\n        \r\n        console.log('Snake dimensions:', {\r\n            baseWidth: dimensions.gameWidth,\r\n            baseHeight: dimensions.gameHeight,\r\n            scale: dimensions.scale,\r\n            scaledWidth: dimensions.gameWidth * dimensions.scale,\r\n            scaledHeight: dimensions.gameHeight * dimensions.scale,\r\n            canvasWidth: canvas.width,\r\n            canvasHeight: canvas.height,\r\n            styleWidth: canvas.style.width,\r\n            styleHeight: canvas.style.height\r\n        });\r\n    }\r\n\r\n    // Create and initialize game\r\n    game = new SnakeGame(app);\r\n    await game.init();\r\n\r\n    // Set up game loop\r\n    app.ticker.add(gameLoop);\r\n    \r\n    // Add resize handler\r\n    window.addEventListener('resize', updateCanvasScaling);\r\n}\r\n\r\nfunction gameLoop(delta: number) {\r\n    if (game) {\r\n        game.update(delta);\r\n    }\r\n}\r\n\r\n// Global functions for game control\r\ndeclare global {\r\n    interface Window {\r\n        restartGame: () => void;\r\n        returnToMainMenu: () => void;\r\n        resumeGame: () => void;\r\n        togglePause: () => void;\r\n    }\r\n}\r\n\r\nwindow.restartGame = () => {\r\n    if (game) {\r\n        game.restart();\r\n    }\r\n};\r\n\r\nwindow.returnToMainMenu = () => {\r\n    window.location.href = '/arcade/';\r\n};\r\n\r\nwindow.resumeGame = () => {\r\n    if (game) {\r\n        game.resume();\r\n    }\r\n};\r\n\r\nwindow.togglePause = () => {\r\n    if (game) {\r\n        game.togglePause();\r\n    }\r\n};\r\n\r\n// Initialize when page loads\r\nwindow.addEventListener('load', initGame); "],"names":["Snake","gridSize","gridWidth","gridHeight","__publicField","Container","Graphics","startX","startY","newDirection","head","newHead","tail","x","y","segment","index","leftEyeX","leftEyeY","rightEyeX","rightEyeY","Food","centerX","centerY","radius","delta","scale","BASE_DIMENSIONS","GRID_SIZE","getGameDimensions","windowWidth","windowHeight","isLandscape","baseDimensions","scaleX","scaleY","SnakeGame","app","background","handleKeydown","event","isSwiping","minSwipeDistance","handleTouchStart","touch","handleTouchMove","handleTouchEnd","deltaX","deltaY","startScreen","gameContainer","startGame","currentTime","gameOverElement","finalScoreElement","pauseMenuElement","scoreElement","highScoreElement","game","updateCanvasScaling","currentDimensions","canvas","newDimensions","currentOrientation","newOrientation","initGame","dimensions","Application","gameLoop"],"mappings":"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"}